# Detailed Semantic Coding

This section presents the detailed semantic coding of the interviews conducted with the seven study participants. The material is structured individually by interviewee to highlight the statements that supported the scoring for each code quality criterion identified in the analysis (readability, maintainability, modularity, standardization, simplicity, and functionality). The categorical organization makes it possible to visualize how different levels of seniority and areas of expertise influenced perceptions of code quality, while also providing textual evidence that supports the analyses discussed in Chapter [ref:cap:llm]. Thus, this section fulfills the role of making the qualitative analysis process transparent, reinforcing the interpretative validity of the presented results.

---

## Interviewee 1 – E1 (Junior)

### Readability

**Statements that generated scoring:**

1. “I like code that’s short but readable.”
2. “Not too summarized, not too long.”
3. “The second one is easier to read.”
4. “I prefer code that you can understand quickly.”

### Simplicity

**Statement that generated scoring:**

1. “Not too summarized, not too long — a middle ground.”

### Functionality

**Statement that generated scoring:**

1. “The code has to be functional.”

### Modularity

**Statements that generated scoring:**

1. “I liked code 2 because it used several classes, object-oriented.”
2. “Organizing in classes helps to understand.”

---
## Interviewee 2 – E2 (Junior)

### Readability

**Statements that generated scoring:**

1. “Code 2 is much more modular, divided responsibilities, more readable.”
2. “I prefer the one that facilitates reading.”
3. “Clear code helps.”

### Maintainability

**Statements that generated scoring:**

1. “Code 2 would be easier in the long run.”
2. “Modularity helps maintenance.”

### Modularity

**Statements that generated scoring:**

1. “Code 2 is well divided, more classes, separated responsibilities.”
2. “Small classes improve modularity.”
3. “Well-defined responsibilities.”

### Simplicity

**Statement that generated scoring:**

1. “Code 1 takes too much responsibility, huge methods, hard to maintain.”

---

## Interviewee 3 – E3 (Junior)

### Readability

**Statements that generated scoring:**

1. “No comparison — code 1 is compact, perfect, well summarized.”
2. “Code 2 is huge and not very readable.”
3. “I prefer code organized in blocks.”

### Maintainability

**Statements that generated scoring:**

1. “Definitely code 1. Compact, easy to maintain.”
2. “Simpler codes are easier to modify.”

### Modularity

**Statement that generated scoring:**

1. “Code 1 is well separated into blocks.”

### Standardization

**Statement that generated scoring:**

1. “Block separation facilitates reading.”

### Functionality

**Statement that generated scoring:**

1. “For a beginner, maybe code 2 would be easier to follow.”

---

## Interviewee 4 – E4 (Mid-Level)

### Readability

**Statements that generated scoring:**

1. “The one on the right is much easier to understand.”
2. “I prefer code that facilitates reading.”
3. “I separate readability from maintenance, but both go together.”

### Maintainability

**Statements that generated scoring:**

1. “The quality of a code is reflected when, over the years, I can still maintain it.”
2. “Separating into classes helps with maintenance.”
3. “Interfaces improve future maintenance.”
4. “Long code makes maintenance difficult.”

### Modularity

**Statements that generated scoring:**

1. “The use of interfaces improves maintainability.”
2. “Separation of responsibilities is important.”
3. “Architecture impacts modularity.”

---

## Interviewee 5 – E5 (Mid-Level)

### Readability

**Statements that generated scoring:**

1. “Clearly, the main thing that makes a code good is being readable and standardized.”
2. “Code 1 has a lot out of standard.”
3. “I prefer standardized and readable code.”
4. “Readability and maintenance go together.”

### Maintainability

**Statements that generated scoring:**

1. “A code needs to be dynamic and scalable. If it isn’t, it becomes outdated quickly.”
2. “Cleaner codes last longer.”
3. “Layer separation facilitates maintenance.”

### Modularity

**Statements that generated scoring:**

1. “I always focus on keeping controllers, views, and models separate.”
2. “MVC architecture facilitates modularity.”
3. “Well-separated classes improve modularity.”

### Standardization

**Statements that generated scoring:**

1. “Code 1 has a lot out of standard.”
2. “Inconsistent naming gets in the way.”

### Functionality

**Statement that generated scoring:**

1. “It also needs to work; it’s not enough to just look good.”

---

## Interviewee 6 – E6 (Senior)

### Readability

**Statements that generated scoring:**

1. “For me, a well-made code has to be readable first. The more readable, the better.”
2. “The one on the right is much easier to understand.”
3. “You can’t see exactly, but the one on the right was reduced well, became more readable.”
4. “Readability is the priority criterion for me.”
5. “I prefer code that anyone can look at and understand.”

### Maintainability

**Statements that generated scoring:**

1. “Code 2, being small and short, is easier to analyze. It would be better in the long term.”
2. “When you separate into different classes, each with its own responsibility, it’s easier to maintain.”
3. “Simplicity helps with future maintenance.”

### Modularity

**Statements that generated scoring:**

1. “The right side was divided into two different classes, each with its own responsibility.”
2. “The use of interfaces helps modularity and maintenance.”

### Standardization

**Statement that generated scoring:**

1. “A well-written code follows naming standards; otherwise, it becomes difficult.”

### Functionality

**Statement that generated scoring:**

1. “The code needs to work correctly, not just look good.”

### Simplicity

**Statements that generated scoring:**

1. “I prefer concise and clear code.”
2. “The fewer unnecessary lines, the better.”

---

## Interviewee 7 – E7 (Senior)

### Readability

**Statements that generated scoring:**

1. “A quality code has to be easy to read, functional, and easy to maintain.”
2. “I prefer clear code.”
3. “Readability facilitates collaboration.”
4. “Readable code reduces errors.”

### Maintainability

**Statements that generated scoring:**

1. “Clear responsibilities, non-complex logic — that facilitates maintenance.”
2. “Simpler codes are easier to maintain.”
3. “I prefer modularization for future maintenance.”

### Modularity

**Statements that generated scoring:**

1. “Responsibilities are modularized in smaller classes.”
2. “Separating responsibilities improves modularity.”

### Standardization

**Statement that generated scoring:**

1. “Naming variables and functions well.”

### Functionality

**Statements that generated scoring:**

1. “A code must be functional.”
2. “Functionality is essential for quality.”
