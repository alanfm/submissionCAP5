# Tables of Interviewees’ Choices and Justifications

This section presents the complete tables containing the participants’ code choices (original or refactored) and their respective justifications (E1–E7).

---


## Table – Interviewee E1: Choices and Justifications Across the Five Comparisons

| **Comparison** | **Chosen Code** | **Justification** |
|----------------|----------------|--------------------|
| 1st | Refactored | “*I see all these characteristics in code 2. [...] it’s shorter, easier to read, better indented. In the first one I get lost in several commands, it’s harder to read and maintain.*” |
| 2nd | Refactored | “*This time I’ll go with code 1 [...] it condensed the code, avoided creating full functions, did everything in one line. I find shorter code easier to read.*” |
| 3rd | Refactored | “*The first one uses too many conditional structures, making it complex. The second is more readable and easier to maintain. [...] Readability is better in 2.*” |
| 4th | Refactored | “*This time the first one is a bit more readable than the second. [...] For testing it also performed better. For maintenance, it would be a bit easier than the second.*” |
| 5th | Refactored | “*I think the first one is more readable and less complex to maintain. So I’d choose number 1, I consider it better.*” |

---

## Table – Interviewee E2: Choices and Justifications Across the Five Comparisons

| **Comparison** | **Chosen Code** | **Justification** |
|----------------|----------------|--------------------|
| 1st | Refactored | “*Code 2 is much more modular, divided, and readable. Code 1 takes too much responsibility, has huge methods, and is harder to maintain.*” |
| 2nd | Refactored | “*Code 2 is much more modularized. Code 1 has excessive responsibility. Code 2 facilitates testing and maintenance.*” |
| 3rd | Refactored | “*Code 2 is more readable, simple, and easier to understand. Code 1 is more complex and harder to figure out what the function does.*” |
| 4th | Refactored | “*Code 2 has high cyclomatic complexity, many nested ifs. Code 1 uses switch-case, which is more readable and easier to maintain.*” |
| 5th | Refactored | “*Definitely code 1. Better readability, modularization, and maintenance. Code 2 is basically a single class doing multiple things, which hurts quality.*” |

------

## Table – Interviewee E3: Choices and Justifications Across the Five Comparisons

| **Comparison** | **Chosen Code** | **Justification** |
|----------------|----------------|--------------------|
| 1st | Refactored | “*There’s no comparison, code 1 is concise, perfect, well summarized. Code 2 is huge and not very readable.*” |
| 2nd | Refactored | “*Code 1 seems more organized; class coupling is well aligned. It covers all qualities: readability, testability, modularity, maintainability.*” |
| 3rd | Original | “*I’d say for beginners, maybe code 2 would be easier to follow, right? For learning purposes. You can follow each step; it’s all there, no need to look elsewhere.*” |
| 4th | Refactored | “*Code 1 is very readable, modularized, compact, perfect. Code 2 has too many ifs and elses, which harm readability.*” |
| 5th | Refactored | “*Definitely code 1. Code 2 is too long, takes a lot of time to understand and maintain.*” |

## Table – Interviewee E4: Choices and Justifications Across the Five Comparisons

| **Comparison** | **Chosen Code** | **Justification** |
|----------------|----------------|--------------------|
| 1st | Refactored | “*Right away, for me, the one on the right is easier to maintain; it’s more readable than just leaving strings.*” |
| 2nd | Refactored | “*Code 2 divides attributes by class; I don’t have to see a bunch of loose variables at the beginning.*” |
| 3rd | Refactored | “*For me, code 2 is much better; it knew how to divide into classes and group responsibilities, making it more readable.*” |
| 4th | Refactored | “*Here code 1 is better: instead of many lines in the `try`, it separates them into a function, which makes maintenance easier. Code 2 has a huge function doing more than one thing.*” |
| 5th | Refactored | “*In 2, the variables were separated into objects; it’s more maintainable, less coupled, more readable, and even more performant.*” |

---

## Table – Interviewee E5: Choices and Justifications Across the Five Comparisons

| **Comparison** | **Chosen Code** | **Justification** |
|----------------|----------------|--------------------|
| 1st | Refactored | “*Code 2 is better because it’s simpler. Code 1 has a lot of non-standard things, text inside the code, and loose variables. Code 2 uses a manager to handle that.*” |
| 2nd | Refactored | “*Clearly the first; the second is very raw, a draft. The first follows good coding practices.*” |
| 3rd | Refactored | “*For maintenance, code 1 is more functional; I can make specific changes. In code 2, validation isn’t as direct and it’s easy to break something.*” |
| 4th | Refactored | “*Code 2 is more divided, well modularized. In code 1, I found only one class. Modularity is essential for long-term maintenance.*” |
| 5th | Refactored | “*Definitely code 1; it’s easier to maintain and improves the software lifecycle. Code 2 has many local variables and little external reuse.*” |

---

## Table – Interviewee E6: Choices and Justifications Across the Five Comparisons

| **Comparison** | **Chosen Code** | **Justification** |
|----------------|----------------|--------------------|
| 1st | Refactored | “*Man, the left side is way too complex… the other one is much cleaner and simpler. Each function in its place… I think it’s number two. No doubt.*” |
| 2nd | Refactored | “*Without a doubt, code 1… For maintenance, definitely code 1. For clarity and adding functionality, I’d choose it.*” |
| 3rd | Refactored | “*Readability on the left side… The right one is too verbose, too complex… coupling too much… The left one is cleaner, with isolated responsibilities.*” |
| 4th | Refactored | “*Both are fine… The first is more verbose but still readable. The second is less verbose and the reading flow is more linear… For maintenance, I’d go with the second.*” |
| 5th | Refactored | “*In terms of readability, the first one is good… If it does the same thing, man, it’s great. For maintainability, I’d choose the first. The second is more complex.*” |

---

## Table – Interviewee E7: Choices and Justifications Across the Five Comparisons

| **Comparison** | **Chosen Code** | **Justification** |
|----------------|----------------|--------------------|
| 1st | Refactored | “*Definitely the one on the right. It’s much easier to understand. Code 1 is long, concentrating responsibilities. Code 2 is more modularized, concise, and has no complex logic.*” |
| 2nd | Refactored | “*Code 1 is more concise, clear methods, names and variables guide understanding. Code 2 has a huge class and is hard to understand, with several repetitive variables.*” |
| 3rd | Refactored | “*Code 2 is more concise and modularized, easier to understand. Code 1 has over 700 lines, different functionalities, and should be refactored.*” |
| 4th | Refactored | “*Code 2 is more concise, grouped by responsibilities. Easier to understand, with well-divided classes. Code 1 has too many unnecessary and repeated conditionals.*” |
| 5th | Refactored | “*Code 1 is more concise, follows the responsibility-grouping standard, and I can understand it quickly. Code 2 has nested loops, complex conditionals, high cyclomatic complexity, and duplication.*” |
